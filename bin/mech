#!/usr/bin/env ruby
require 'matrix'
require 'sdl2'


class Numeric
  def limit abs_value
    if self > abs_value
      abs_value
    elsif self < -abs_value
      -abs_value
    else
      self
    end
  end

  def limit_angle abs_value
    angle = self % (2 * Math::PI)
    if angle <= abs_value or angle >= 2 * Math::PI - abs_value
      self
    else
      if angle <= Math::PI
        abs_value
      else
        -abs_value
      end
    end
  end
end


class Vector
  def angle
    Math.atan2 self[1], self[0]
  end
end


class Matrix
  def self.rotation angle
    c, s = Math.cos(angle), Math.sin(angle)
    Matrix[[c, -s], [s, c]]
  end
end


class Sprite
  def initialize renderer, file_name, count
    @sprite = (0...count).map { |i| renderer.create_texture_from SDL2::Surface.load file_name % i }
    @count = count
  end

  def index angle
    (angle * @count / (2 * Math::PI)).round % @count
  end

  def rectangle position
    x, y = *position
    w, h = @sprite.first.w, @sprite.first.h
    SDL2::Rect[x - w / 2, y - h / 2, w, h]
  end

  def paint renderer, position, direction
    sprite = @sprite[index(direction)]
    renderer.copy sprite, nil, rectangle(position)
  end
end


class MechGraphics
  def initialize renderer
    @body_sprite = Sprite.new renderer, 'data/mech%02d.png', 36
    @turret_sprite = Sprite.new renderer, 'data/turret%02d.png', 36
  end

  def paint renderer, physics
    @body_sprite.paint renderer, physics.position, physics.direction
    @turret_sprite.paint renderer, physics.turret_position, physics.turret_direction
  end
end


class Physics
  MAX_SPEED = 100.0
  TURN_RATE = 2 * Math::PI / 4
  TURRET_TURN_RATE = 2 * Math::PI
  ACCELERATION = 50

  attr_reader :position
  attr_reader :direction

  def initialize position
    @position = position
    @direction = 0
    @speed = 0
    @turret_direction = 0
  end

  def update joystick, dt
    if joystick
      nominal_speed = joystick.axes.norm * MAX_SPEED / Joystick::MAX_AXIS
      nominal_direction = joystick.axes.angle
      nominal_turret_direction = joystick.turret_axes.angle - @direction
    else
      nominal_speed = 0
      nominal_direction = 0
      nominal_turret_direction = 0
    end
    speed_change = (nominal_speed - @speed).limit ACCELERATION * dt
    direction_change = (nominal_direction - @direction).limit_angle TURN_RATE * dt
    turret_direction_change = (nominal_turret_direction - @turret_direction).limit_angle TURRET_TURN_RATE * dt
    @direction = (@direction + direction_change) % (2 * Math::PI)
    @turret_direction = (@turret_direction + turret_direction_change) % (2 * Math::PI)
    @speed += speed_change
    @position += speed * dt
  end

  def speed
    Matrix.rotation(@direction) * Vector[@speed, 0]
  end

  def turret_position
    @position + Matrix.rotation(@direction) *  Vector[-20, -20]
  end

  def turret_direction
    @direction + @turret_direction
  end
end


class Joystick
  MAX_AXIS = 32768

  attr_reader :quit

  def initialize event
    @device = SDL2::Joystick.open event.which
    @axes = [0, 0]
    @turret_axes = [0, 0]
    @button = false
    @quit = false
  end

  def handle_motion event
    @axes[0] = event.value if event.axis == 0
    @axes[1] = event.value if event.axis == 1
    @turret_axes[0] = event.value if event.axis == 3
    @turret_axes[1] = event.value if event.axis == 4
  end

  def handle_button event
    @button = true if event.button == 4 or event.button == 5
    @quit = true if event.button == 8
  end

  def axes
    Vector[*@axes]
  end

  def turret_axes
    Vector[*@turret_axes]
  end

  def button
    retval = @button
    @button = false
    retval
  end
end


class Game
  def initialize
    SDL2.init SDL2::INIT_VIDEO | SDL2::INIT_JOYSTICK | SDL2::INIT_AUDIO
    SDL2::Mixer.init SDL2::Mixer::INIT_OGG
    SDL2::Mixer.open 22050, SDL2::Mixer::DEFAULT_FORMAT, 2, 512
    @window = SDL2::Window.create 'Mech', SDL2::Window::POS_UNDEFINED, SDL2::Window::POS_UNDEFINED, 640, 480, SDL2::Window::Flags::FULLSCREEN_DESKTOP
    w, h = *@window.size
    @renderer = @window.create_renderer -1, 0
    @mech_graphics = MechGraphics.new @renderer
    @mech_physics = Physics.new Vector[w/2, h/2]
    @laser_sound = SDL2::Mixer::Chunk.load 'data/laser.ogg'
    @quit = false
  end

  def handle_events
    while event = SDL2::Event.poll
      case event
      when SDL2::Event::Quit
        @quit = true
      when SDL2::Event::JoyDeviceAdded
        @joystick = Joystick.new event
      when SDL2::Event::JoyAxisMotion
        @joystick.handle_motion event
      when SDL2::Event::JoyButtonDown
        @joystick.handle_button event
      end
    end
    if @joystick
      SDL2::Mixer::Channels.play 0, @laser_sound, 0 if @joystick.button
      @quit ||= @joystick.quit
    end
  end

  def paint
    @renderer.draw_color = [0xA0, 0xA0, 0xA0]
    @renderer.clear
    @mech_graphics.paint @renderer, @mech_physics
    @renderer.present
  end

  def run
    time = Time.new.to_f
    while not @quit
      paint
      handle_events
      dt = Time.new.to_f - time
      if dt < 0.04
        sleep 0.04 - dt
        dt = 0.04
      end
      @mech_physics.update @joystick, dt
      time += dt
    end
  end
end


Game.new.run
